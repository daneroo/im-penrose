<svg xmlns='http://www.w3.org/2000/svg' viewBox='-10 -10 20 20'>
<script type="text/ecmascript"><![CDATA[
  var root;
  var svgns = 'http://www.w3.org/2000/svg';

  // from solarized accents: http://ethanschoonover.com/solarized
  var solarized = {
    yellow:'#b58900',
    orange:'#CB4B16',
    red:'#DC322F',
    magenta:'#D33682',
    violet:'#6C71C4',
    blue:'#268BD2',
    cyan:'#2AA198',
    green:'#859900'
  }; 

  function drawPoint(p,clr,thick,opa){ 
      var circle = root.ownerDocument.createElementNS(svgns, 'circle');      
      circle.setAttribute('opacity', opa||'1');
      circle.setAttribute('stroke','none');
      circle.setAttribute('fill', clr||'gray');
      
      circle.setAttribute('cx', p.x);
      circle.setAttribute('cy', p.y);
      circle.setAttribute('r', thick||0.05  );
      root.appendChild(circle);
  }
  function drawSegment(p1,p2,clr,thick,opa){
    var line = root.ownerDocument.createElementNS(svgns, 'line');
    line.setAttribute('opacity', opa||'1');
    line.setAttribute('stroke-width', thick|| 0.01);
    line.setAttribute('stroke', clr||'gray');
    line.setAttribute('x1', p1.x);
    line.setAttribute('y1', p1.y);
    line.setAttribute('x2', p2.x);
    line.setAttribute('y2', p2.y);    
    root.appendChild(line);
  }
  function toRad(deg){return deg*Math.PI/180;}
  function toDeg(rad){return rad*180/Math.PI;}
  function vmult(s,p){ // s:scalar, p={x,y}
    return {x:s*p.x,y:s*p.y};
  }
  function vadd(p1,p2){ // s:scalar, p={x,y}
    return {x:p1.x*p2.x,y:p1.y*p2.y};
  }
  function norm(p){
    var n = Math.sqrt(p.x*p.x+p.y*p.y);
    console.log('norm',[p.x.toFixed(5),p.y.toFixed(5)],n)
    return n;
  }
  function drawLine(angle,off,clr,thick,opa){ // 
    var path = root.ownerDocument.createElementNS(svgns, 'path');
    path.setAttribute('opacity', opa||'1');
    path.setAttribute('stroke-width', thick|| 0.01);
    path.setAttribute('stroke', clr||'gray');
    var line = 'M-1000,0 L1000,0';
    path.setAttribute('d', line);
    path.setAttribute('transform', 'translate('+off.x+','+off.y+') rotate('+angle+')');
    root.appendChild(path);
  }
  function intersect(i0,n0,i1,n1){
    // intersect e0_n0 && e1_n1
    var e0 = e[i0];
    var e1 = e[i1];
    var n0g0e0 = {x:(n0+g[i0])*e[i0].x, y:(n0+g[i0])*e[i0].y};
    var n1g1e1 = {x:(n1+g[i1])*e[i1].x, y:(n1+g[i1])*e[i1].y};
    // e0.y * (y-n0g0e0.y) =  -e0.x * (x-n0g0e0.x)
    // isolate x - requires e0.x!=0
    // e0.y * (y-n0g0e0.y) =  -e0.x * (x-n0g0e0.x)
    // -e0.y/e0.x * (y-n0g0e0.y) =   x-n0g0e0.x
    // (-e0.y/e0.x * (y-n0g0e0.y))+n0g0e0.x = x
    // x = (-e0.y/e0.x * (y-n0g0e0.y))+n0g0e0.x

    // e1.y * (y-n1g1e1.y) =  -e1.x * (x-n1g1e1.x)
    // isolate y  - requires e1.y!=0
    // y - n1g1e1.y =  -e1.x/e1.y * (x-n1g1e1.x)
    // y =  -e1.x/e1.y * (x-n1g1e1.x) + n1g1e1.y

    // Simplify:
    // x = (-e0.y/e0.x*(y-n0g0e0.y)) + g0e0.x
    // x = (A*(y-n0g0e0.y)) + n0g0e0.x   with A = -e0.y/e0.x
    // x = (A*y-A*n0g0e0.y) + n0g0e0.x
    // x = A*y - A*n0g0e0.y + n0g0e0.x
    // x = A*y + B   with B = -A*n0g0e0.y + n0g0e0.x

    // y = -e1.x/e1.y * (x-n1g1e1.x) + n1g1e1.y
    // y = C * (x-n1g1e1.x) + n1g1e1.y   with C = -e1.x/e1.y
    // y = C*x - C*n1g1e1.x + n1g1e1.y
    // y = C*x + D   with D = -C*n1g1e1.x + n1g1e1.y

    // Intersection:
    // x = A*y + B
    // y = C*x + D
    // y = C*(A*y + B) + D  <-- substitute x
    // y = C*A*y + C*B + D
    // y * (1-C*A) = C*B + D
    // y  = ( C*B + D ) / (1-C*A)

    var A = -e0.y/e0.x;
    var B = -A*n0g0e0.y + n0g0e0.x;
    var C = -e1.x/e1.y;
    var D = -C*n1g1e1.x + n1g1e1.y;
    // console.log('ABCD',A,B,C,D);
    var y = ( C*B + D ) / (1-C*A);
    // console.log('y',y);    
    var x = A*y + B
    // console.log('x',x);
    
    // return intersection point
    return {x:x,y:y};
  }
  
  function projectCube(){
    var cube=[0,1];
    cube.forEach(function(n0){
      cube.forEach(function(n1){
        cube.forEach(function(n2){
          cube.forEach(function(n3){
            cube.forEach(function(n4){
              var n = [n0,n1,n2,n3,n4];
              var p = { x:0, y:0 };
              for (var i=0;i<5;i++) {
                p.x+= n[i]*e[i].x;
                p.y+= n[i]*e[i].y;
              }
              drawPoint(p,'green',0.06,0.25);
            });
          });
        });
      });
    });
  }
  

  var eDeg = [];  // angles for basis vectors
  var e = []; // basis vectors
   // translation gamma_i
   var g=[0.3273951115552336, 0.6228435167577118, 0.5536088130902499, 0.12421905994415283, 0.6411375142633915];
   var g=[0.5,0.5,0.5,0.5,0.5];
  for (var i=0;i<5;i++) {
    deg=90+i*72;
    rad=toRad(deg)
    eDeg.push(deg);
    e.push({x:-Math.sin(rad),y:Math.cos(rad)})
    // g.push(Math.random());
    // norm(e[i]);
  }
  var pColor=[solarized.yellow,solarized.magenta,solarized.violet,solarized.cyan,solarized.green];
  var range=[]; for (var i=-50;i<=50;i++)range.push(i);
  function start(evt) {
    root = evt.target;

    // grid
    if(1) {
      range.forEach(function(i){
        drawLine(0,{x:0,y: i},null,null,0.1);        
        drawLine(90,{x: i,y:0},null,null,0.1);
      });
      drawPoint({x:0,y:0},'grey',0.05,0.3);
    }

    for (var i=0;i<eDeg.length;i++){
      var deg=eDeg[i],c=pColor[i];
      // drawLine(deg,{x:0,y:0},c,0.02);        
      range.forEach(function(n){
        drawLine(deg,vmult(n+g[i],e[i]),c,0.005);
      });
    }

    // projectCube();

    function intersectAndRhomb(i0,n0,i1,n1){
      var intr = intersect(i0,n0,i1,n1);
      // drawPoint(intr,'red',0.05,0.5);

      var drawBands = false;
      if (drawBands){
        // 2 unit wide intersection for selected axis i0
        drawLine(eDeg[i0],vmult(n0+g[i0],e[i0]),pColor[i0],2,.1);
        // or same with 2 - one unit bands
        drawLine(eDeg[i0],vmult(n0-.5+g[i0],e[i0]),pColor[i0],1,.1);
        drawLine(eDeg[i0],vmult(n0+.5+g[i0],e[i0]),pColor[i0],1,.1);

        // 2 unit wide intersection for selected axis i0
        drawLine(eDeg[i1],vmult(n1+g[i1],e[i1]),pColor[i1],2,.1);
        // or same with 2 - one unit bands
        drawLine(eDeg[i1],vmult(n1-.5+g[i1],e[i1]),pColor[i1],1,.1);
        drawLine(eDeg[i1],vmult(n1+.5+g[i1],e[i1]),pColor[i1],1,.1);
      }

      // How do we find n's
      // one unit wide for other axis.
      var n2=0;
      // drawLine(eDeg[2],vmult(n2-.5+g[2],e[2]),pColor[2],1,.1);
      var n3=-5;
      // drawLine(eDeg[3],vmult(n3-.5+g[3],e[3]),pColor[3],1,.1);
      var n4=-1;
      // drawLine(eDeg[4],vmult(n4-.5+g[4],e[4]),pColor[4],1,.1);
      
      var n=[null,null,null,null,null];
      for (var i=0;i<5;i++){
        // x = A*y + B   with A = -e0.y/e0.x, B = -A*n0g0e0.y + n0g0e0.x, e0.x!=0        
        // x-A*y = B = (n0+g0) * (-Ae0.y+e0.x)
        // n0 = (x-A*y)/(-Ae0.y+e0.x) - g0 with A = -e0.y/e0.x, e0.x!=0        
        if (e[i].x!==0){
          var A= -e[i].y/e[i].x;
          n[i] = (intr.x-A*intr.y)/(-A*e[i].y+e[i].x) -g[i];
          // console.log('x-> n['+i+']=',Math.floor(n[i]),n[i]);
        }

        // y = C*x + D   with C = -e1.x/e1.y, D = -C*n1g1e1.x + n1g1e1.y, e0.y!=0
        //    D = -C*(n1+g1)*e1.x + (n1+g1)*e1.y = (n1+g1) * (-C*e1.x+e1.y)
        // y-Cx = D = (n1+g1) * (-C*e1.x + e1.y)
        // n1 = (y-Cx)/(-C*e1.x + e1.y) -g1 with C = -e1.x/e1.y, e0.y!=0
        if (e[i].y!==0){
          var C = -e[i].x/e[i].y;
          n[i] = (intr.y-C*intr.x)/(-C*e[i].x+e[i].y) -g[i];
          // console.log('y-> n['+i+']=',Math.floor(n[i]),n[i]);
        }
        n[i] = Math.floor(n[i]);
        // n[i] = Math.ceil(n[i]);
        if (drawBands){
          drawLine(eDeg[i],vmult(n[i]-.5+g[i],e[i]),pColor[i],1,.3);
        }
      }
      
      n0s=[n0-1,n0];
      n1s=[n1-1,n1];
      var rh=[];
      n0s.forEach(function(ni0){
        n1s.forEach(function(ni1){
          var nn = n.slice(0);
          nn[i0]=ni0;
          nn[i1]=ni1;
          var p = { x:0, y:0 };
          for (var i=0;i<5;i++) {
            p.x+= nn[i]*e[i].x;
            p.y+= nn[i]*e[i].y;
          }
          rh.push(p);
          // drawPoint(p,'blue',0.1,0.1);
        });
      });
      drawSegment(rh[0],rh[1],pColor[i1],0.04);
      drawSegment(rh[2],rh[3],pColor[i1],0.04);
      drawSegment(rh[0],rh[2],pColor[i0],0.04);
      drawSegment(rh[1],rh[3],pColor[i0],0.04);
    }
    // select axis and replica
    // var i0=2,i1=3; // if e0.x==0 -> swap
    // n0, and n1 select the nth reoplica line in e0,e1 translations
    // var n0=-1, n1=0;
    // intersectAndRhomb(i0,n0, i1,n1)
    var rr = [-5,-4,-3,-2,-1,0,1,2,3,4,5];
    var ii=[0,1,2,3,4];
    ([0]).forEach(function(i0){
      ii.forEach(function(i1){
        if (i1!==i0) rr.forEach(function(n0){
          rr.forEach(function(n1){
            intersectAndRhomb(i0,n0, i1,n1);
          });
        });
      });
    });
  }
  
]]></script>
  <g transform="scale(1,-1)">
    <g id="rotation" transform="rotate(0)">
      <g id="root" stroke="black" fill="none" onload="start(evt)"/>
    </g>
  </g>
</svg>
